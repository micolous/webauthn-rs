use std::mem::size_of;

use openssl::symm::{decrypt_aead, encrypt_aead, Cipher};

use crate::error::WebauthnCError;

pub type EncryptionKey = [u8; 32];
const OLD_ADDITIONAL_BYTES: [u8; 1] = [/* version */ 2];
const NEW_ADDITIONAL_BYTES: [u8; 0] = [];
const PADDING_MUL: usize = 32;

/// Encrypted message passing channel for caBLE
#[derive(Default)]
pub struct Crypter {
    read_key: EncryptionKey,
    write_key: EncryptionKey,
    read_seq: u32,
    write_seq: u32,

    /// Using "new construction" (caBLE v2.1+) changes the protocol to be more
    /// like regular Noise, by removing "additional bytes" and using a
    /// big-endian `read_seq` / `write_seq` nonce.
    ///
    /// Crypter will automatically switch to this mode if the first call to
    /// [Crypter::decrypt] contains a message encrypted in `new_construction`
    /// mode.
    new_construction: bool,
}

impl Crypter {
    pub fn new(read_key: EncryptionKey, write_key: EncryptionKey) -> Self {
        Self {
            read_key,
            write_key,
            ..Default::default()
        }
    }

    pub fn encrypt(&mut self, msg: &[u8]) -> Result<Vec<u8>, WebauthnCError> {
        let padded = pad(msg);

        let nonce = self.construct_nonce(self.write_seq);
        self.write_seq += 1;
        let cipher = Cipher::aes_256_gcm();
        let aad = if self.new_construction {
            &NEW_ADDITIONAL_BYTES[..]
        } else {
            &OLD_ADDITIONAL_BYTES[..]
        };
        let mut tag = [0; 16];

        let mut encrypted = encrypt_aead(
            cipher,
            &self.write_key,
            Some(&nonce),
            aad,
            &padded,
            &mut tag,
        )?;
        encrypted.reserve(16);
        encrypted.extend_from_slice(&tag);

        Ok(encrypted)
    }

    pub fn decrypt(&mut self, ct: &[u8]) -> Result<Vec<u8>, WebauthnCError> {
        let nonce = self.construct_nonce(self.read_seq);
        let cipher = Cipher::aes_256_gcm();
        let aad = if self.new_construction {
            &NEW_ADDITIONAL_BYTES[..]
        } else {
            &OLD_ADDITIONAL_BYTES[..]
        };

        let msg_len = ct.len() - 16;
        trace!(
            "decrypt(ct={:?}, tag={:?}, nonce={:?})",
            &ct[..msg_len],
            &ct[msg_len..],
            &nonce
        );

        let decrypted = decrypt_aead(
            cipher,
            &self.read_key,
            Some(&nonce),
            aad,
            &ct[..msg_len],
            &ct[msg_len..],
        );
        trace!("decrypted: {:?}", decrypted);

        let mut decrypted = match decrypted {
            Err(e) => {
                if !self.new_construction && self.read_seq == 0 {
                    // Switch to new construction mode
                    trace!("trying new construction");
                    self.new_construction = true;
                    return self.decrypt(ct);
                } else {
                    // throw original error
                    return Err(e.into());
                }
            }

            Ok(decrypted) => decrypted,
        };

        self.read_seq += 1;

        if decrypted.is_empty() {
            error!("Invalid caBLE message (empty)");
            return Err(WebauthnCError::Internal);
        }

        unpad(&mut decrypted)?;
        Ok(decrypted)
    }

    fn construct_nonce(&self, counter: u32) -> [u8; 12] {
        let mut nonce = [0; 12];
        if self.new_construction {
            nonce[12 - size_of::<u32>()..].copy_from_slice(&counter.to_be_bytes());
        } else {
            nonce[..size_of::<u32>()].copy_from_slice(&counter.to_le_bytes());
        }
        trace!(
            "new_constuction: {:?}, nonce: {:?}",
            self.new_construction,
            nonce
        );
        nonce
    }

    #[cfg(test)]
    /// Returns `true` if the `other` [Crypter] uses "remote side" (swapped)
    /// read and write keys.
    ///
    /// This function is only useful for testing.
    pub(super) fn is_counterparty(&self, other: &Self) -> bool {
        self.read_key == other.write_key && self.write_key == other.read_key
    }

    /// Switches to "new construction", for caBLE v2.1+.
    pub fn use_new_construction(&mut self) {
        self.new_construction = true;
    }
}

/// Pads a message to a multiple of [PADDING_MUL] bytes.
///
/// See also: [unpad]
fn pad(msg: &[u8]) -> Vec<u8> {
    let padded_len = (msg.len() + PADDING_MUL) & !(PADDING_MUL - 1);
    assert!(padded_len > msg.len());
    let zeros = padded_len - msg.len() - 1;
    assert!(zeros < 256);

    let mut padded = vec![0; padded_len];
    padded[..msg.len()].copy_from_slice(&msg);
    padded[padded_len - 1] = zeros as u8;
    padded
}

/// Unpads a message padded with [pad].
fn unpad(msg: &mut Vec<u8>) -> Result<(), WebauthnCError> {
    let padding_len = (msg.last().map(|l| *l).unwrap_or_default() as usize) + 1;
    if padding_len > msg.len() {
        error!(
            "Invalid caBLE message (padding length {} > message length {})",
            padding_len,
            msg.len()
        );
        return Err(WebauthnCError::Internal);
    }

    msg.truncate(msg.len() - padding_len);
    Ok(())
}

#[cfg(test)]
mod test {
    use std::collections::BTreeMap;

    use base64urlsafedata::Base64UrlSafeData;
    use webauthn_rs_proto::{PubKeyCredParams, PublicKeyCredentialDescriptor, RelyingParty, User};

    use crate::{
        cable::framing::{CableFrame, MessageType},
        ctap2::{commands::MakeCredentialRequest, CBORCommand},
    };

    use super::*;

    #[test]
    fn encrypt_decrypt() {
        let _ = tracing_subscriber::fmt::try_init();

        let key0 = [123; 32];
        let key1 = [231; 32];

        let mut alice = Crypter::new(key0, key1);
        let mut bob = Crypter::new(key1, key0);
        let mut corrupted = Crypter::new(key1, key0);

        for l in 0..530 {
            let msg = vec![0xff; l];
            let mut crypted = alice.encrypt(&msg).unwrap();
            let decrypted = bob.decrypt(&crypted).unwrap();

            assert_eq!(msg, decrypted);
            assert!(!bob.new_construction);
            if l > 0 {
                crypted[(l * 3) % l] ^= 0x01;
            }
            corrupted.read_seq = bob.read_seq;
            assert!(corrupted.decrypt(&crypted).is_err());
        }
    }

    #[test]
    fn encrypt_decrypt_new() {
        let _ = tracing_subscriber::fmt::try_init();

        let key0 = [123; 32];
        let key1 = [231; 32];

        let mut alice = Crypter::new(key0, key1);
        alice.use_new_construction();
        let mut bob = Crypter::new(key1, key0);
        let mut corrupted = Crypter::new(key1, key0);

        for l in 1..5 {
            let msg = vec![0xff; l];
            let mut crypted = alice.encrypt(&msg).unwrap();
            let decrypted = bob.decrypt(&crypted).unwrap();

            assert!(bob.new_construction);
            assert_eq!(msg, decrypted);
            if l > 0 {
                crypted[(l * 3) % l] ^= 0x01;
            }
            corrupted.new_construction = bob.new_construction;
            corrupted.read_seq = bob.read_seq;
            assert!(corrupted.decrypt(&crypted).is_err());
        }
    }

    #[test]
    fn construction() {
        let _ = tracing_subscriber::fmt::try_init();
        // Patched chromium to leak its key data
        let write_key = [
            0x1f, 0xba, 0x3c, 0xce, 0x17, 0x62, 0x2c, 0x68, 0x26, 0x8d, 0x9f, 0x75, 0xb5, 0xa8,
            0xa3, 0x35, 0x1b, 0x51, 0x7f, 0x9, 0x6f, 0xb5, 0xe2, 0x94, 0x94, 0x1a, 0xf7, 0xe3,
            0xa6, 0xa8, 0xd6, 0xe1,
        ];
        let read_key = [
            0xe3, 0x4f, 0x1a, 0xa3, 0x74, 0x72, 0x38, 0xc0, 0x4d, 0x3b, 0xd2, 0x5e, 0x7, 0xef,
            0x1b, 0x35, 0xfe, 0xf3, 0x59, 0x0, 0xd, 0x75, 0x56, 0x15, 0xcd, 0x85, 0xbe, 0x27, 0xcf,
            0xc8, 0x7, 0xd1,
        ];
        let req = MakeCredentialRequest {
            client_data_hash: vec![
                0x38, 0x89, 0x28, 0x5c, 0x8c, 0x63, 0x23, 0x95, 0xc, 0xed, 0x7, 0x49, 0x84, 0xf9,
                0xf9, 0x46, 0x3b, 0xc1, 0x73, 0x9b, 0xb6, 0x21, 0xa9, 0xe5, 0xf1, 0xee, 0x8d, 0xd9,
                0x39, 0x3b, 0xa2, 0x80,
            ],
            rp: RelyingParty {
                name: String::from("webauthn.firstyear.id.au"),
                id: String::from("webauthn.firstyear.id.au"),
            },
            user: User {
                id: Base64UrlSafeData::from(vec![
                    0xd6, 0xd7, 0xaa, 0x29, 0x8f, 0xe8, 0x4a, 0x6, 0xaa, 0xde, 0xd7, 0xe4, 0x9d,
                    0x90, 0xa, 0x62,
                ]),
                name: String::from("a"),
                display_name: String::from("a"),
            },
            pub_key_cred_params: vec![
                PubKeyCredParams {
                    type_: String::from("public-key"),
                    alg: -7,
                },
                PubKeyCredParams {
                    type_: String::from("public-key"),
                    alg: -257,
                },
            ],
            exclude_list: vec![PublicKeyCredentialDescriptor {
                type_: String::from("public-key"),
                id: Base64UrlSafeData::from(vec![0, 1, 2, 3]),
                transports: None,
            }],
            options: Some(BTreeMap::from([(String::from("uv"), true)])),
            pin_uv_auth_param: None,
            pin_uv_auth_proto: None,
            enterprise_attest: None,
        };

        let req = CableFrame {
            protocol_version: 1,
            message_type: MessageType::Ctap,
            data: req.cbor().unwrap(),
        };

        let expected_req_encoding = [
            0x1, 0x1, 0xa6, 0x1, 0x58, 0x20, 0x38, 0x89, 0x28, 0x5c, 0x8c, 0x63, 0x23, 0x95, 0xc,
            0xed, 0x7, 0x49, 0x84, 0xf9, 0xf9, 0x46, 0x3b, 0xc1, 0x73, 0x9b, 0xb6, 0x21, 0xa9,
            0xe5, 0xf1, 0xee, 0x8d, 0xd9, 0x39, 0x3b, 0xa2, 0x80, 0x2, 0xa2, 0x62, 0x69, 0x64,
            0x78, 0x18, 0x77, 0x65, 0x62, 0x61, 0x75, 0x74, 0x68, 0x6e, 0x2e, 0x66, 0x69, 0x72,
            0x73, 0x74, 0x79, 0x65, 0x61, 0x72, 0x2e, 0x69, 0x64, 0x2e, 0x61, 0x75, 0x64, 0x6e,
            0x61, 0x6d, 0x65, 0x78, 0x18, 0x77, 0x65, 0x62, 0x61, 0x75, 0x74, 0x68, 0x6e, 0x2e,
            0x66, 0x69, 0x72, 0x73, 0x74, 0x79, 0x65, 0x61, 0x72, 0x2e, 0x69, 0x64, 0x2e, 0x61,
            0x75, 0x3, 0xa3, 0x62, 0x69, 0x64, 0x50, 0xd6, 0xd7, 0xaa, 0x29, 0x8f, 0xe8, 0x4a, 0x6,
            0xaa, 0xde, 0xd7, 0xe4, 0x9d, 0x90, 0xa, 0x62, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x61,
            0x61, 0x6b, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x61,
            0x61, 0x4, 0x82, 0xa2, 0x63, 0x61, 0x6c, 0x67, 0x26, 0x64, 0x74, 0x79, 0x70, 0x65,
            0x6a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x2d, 0x6b, 0x65, 0x79, 0xa2, 0x63, 0x61,
            0x6c, 0x67, 0x39, 0x1, 0x0, 0x64, 0x74, 0x79, 0x70, 0x65, 0x6a, 0x70, 0x75, 0x62, 0x6c,
            0x69, 0x63, 0x2d, 0x6b, 0x65, 0x79, 0x5, 0x81, 0xa2, 0x62, 0x69, 0x64, 0x44, 0x0, 0x1,
            0x2, 0x3, 0x64, 0x74, 0x79, 0x70, 0x65, 0x6a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x2d,
            0x6b, 0x65, 0x79, 0x7, 0xa1, 0x62, 0x75, 0x76, 0xf5,
        ];

        let r = req.to_bytes();

        assert_eq!(r, expected_req_encoding);

        let expected_req_padded = [
            0x1, 0x1, 0xa6, 0x1, 0x58, 0x20, 0x38, 0x89, 0x28, 0x5c, 0x8c, 0x63, 0x23, 0x95, 0xc,
            0xed, 0x7, 0x49, 0x84, 0xf9, 0xf9, 0x46, 0x3b, 0xc1, 0x73, 0x9b, 0xb6, 0x21, 0xa9,
            0xe5, 0xf1, 0xee, 0x8d, 0xd9, 0x39, 0x3b, 0xa2, 0x80, 0x2, 0xa2, 0x62, 0x69, 0x64,
            0x78, 0x18, 0x77, 0x65, 0x62, 0x61, 0x75, 0x74, 0x68, 0x6e, 0x2e, 0x66, 0x69, 0x72,
            0x73, 0x74, 0x79, 0x65, 0x61, 0x72, 0x2e, 0x69, 0x64, 0x2e, 0x61, 0x75, 0x64, 0x6e,
            0x61, 0x6d, 0x65, 0x78, 0x18, 0x77, 0x65, 0x62, 0x61, 0x75, 0x74, 0x68, 0x6e, 0x2e,
            0x66, 0x69, 0x72, 0x73, 0x74, 0x79, 0x65, 0x61, 0x72, 0x2e, 0x69, 0x64, 0x2e, 0x61,
            0x75, 0x3, 0xa3, 0x62, 0x69, 0x64, 0x50, 0xd6, 0xd7, 0xaa, 0x29, 0x8f, 0xe8, 0x4a, 0x6,
            0xaa, 0xde, 0xd7, 0xe4, 0x9d, 0x90, 0xa, 0x62, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x61,
            0x61, 0x6b, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x61,
            0x61, 0x4, 0x82, 0xa2, 0x63, 0x61, 0x6c, 0x67, 0x26, 0x64, 0x74, 0x79, 0x70, 0x65,
            0x6a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x2d, 0x6b, 0x65, 0x79, 0xa2, 0x63, 0x61,
            0x6c, 0x67, 0x39, 0x1, 0x0, 0x64, 0x74, 0x79, 0x70, 0x65, 0x6a, 0x70, 0x75, 0x62, 0x6c,
            0x69, 0x63, 0x2d, 0x6b, 0x65, 0x79, 0x5, 0x81, 0xa2, 0x62, 0x69, 0x64, 0x44, 0x0, 0x1,
            0x2, 0x3, 0x64, 0x74, 0x79, 0x70, 0x65, 0x6a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x2d,
            0x6b, 0x65, 0x79, 0x7, 0xa1, 0x62, 0x75, 0x76, 0xf5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f,
        ];
        let p = pad(&r);
        assert_eq!(p, expected_req_padded);

        let expected_req_crypted = [
            0x50, 0x62, 0xcf, 0x34, 0x57, 0x1e, 0x8, 0x27, 0xa7, 0xc0, 0x20, 0x7f, 0x7c, 0x0, 0x18,
            0x45, 0x67, 0xd6, 0x13, 0xea, 0xb0, 0xda, 0x8, 0xa, 0xd0, 0x42, 0xd8, 0x6, 0x64, 0xc5,
            0x9d, 0xf7, 0xb0, 0x1a, 0x13, 0xdb, 0x17, 0xfd, 0x27, 0x75, 0x75, 0xcc, 0xff, 0x53,
            0xb6, 0xa3, 0x4f, 0xdb, 0x4f, 0xbc, 0xf8, 0x32, 0xf3, 0xd3, 0x60, 0xf8, 0xe5, 0xa7,
            0xda, 0xee, 0x7f, 0x26, 0x5a, 0x92, 0x53, 0xa9, 0x4, 0xd6, 0xeb, 0xff, 0x2f, 0x93,
            0x70, 0xd3, 0x55, 0x36, 0xd8, 0xbf, 0x5, 0x48, 0x30, 0xaa, 0xad, 0xff, 0xb9, 0x96,
            0xb4, 0x20, 0xb2, 0xb3, 0x17, 0xa, 0xc8, 0xa, 0x83, 0x79, 0x68, 0x23, 0xed, 0x3c, 0x28,
            0x4b, 0x17, 0x7c, 0x23, 0x40, 0xc, 0xa0, 0x12, 0x4d, 0x6a, 0x68, 0x26, 0x3d, 0x39,
            0x78, 0x3c, 0xfe, 0xf0, 0x27, 0x3f, 0xdf, 0x3b, 0xfc, 0xfa, 0xa, 0x6c, 0x33, 0xdf,
            0x31, 0x9b, 0x12, 0x6f, 0x6e, 0x82, 0x90, 0xd2, 0x2c, 0x4c, 0xd3, 0x2a, 0x7a, 0x97,
            0x88, 0x56, 0xba, 0x22, 0x73, 0xd1, 0xbe, 0x1c, 0xa, 0x29, 0x1e, 0x5e, 0xe1, 0x97,
            0x41, 0x6a, 0xa0, 0xf7, 0xa1, 0x4, 0xe4, 0xd0, 0xac, 0x58, 0x2b, 0x70, 0x84, 0x82,
            0x32, 0x6d, 0x5f, 0xf0, 0xf1, 0x76, 0x8c, 0x14, 0x16, 0xd0, 0x16, 0xb1, 0xf8, 0x92,
            0x42, 0xe7, 0xe, 0x80, 0x31, 0x2f, 0xe6, 0xb6, 0xd4, 0x2, 0x9a, 0x40, 0xad, 0xa3, 0x74,
            0xb3, 0x1e, 0x7d, 0x66, 0xfa, 0xc3, 0xba, 0x72, 0x83, 0x94, 0x4b, 0x9b, 0x60, 0xda,
            0x4b, 0x98, 0xf6, 0x78, 0x4, 0x9, 0x5f, 0xd3, 0x9c, 0xd1, 0xd4, 0x5d, 0x75, 0xc9, 0x3d,
            0x2d, 0x86, 0xcb, 0xfc, 0x21, 0x61, 0x6f, 0x9f, 0x1a, 0x57, 0x6c, 0xcf, 0x8c, 0x86,
            0x2e, 0xe1, 0x85, 0x12, 0x5f, 0xc1, 0xed, 0x7e, 0xd2, 0x48, 0x6e, 0x2c, 0x5f, 0xbf,
            0xc3, 0x9c, 0x91, 0x95, 0x97, 0xdd, 0x86, 0xc3, 0x38, 0xe7, 0xdf, 0x55, 0x3d, 0x51,
            0xe8,
        ];
        let mut crypter = Crypter::new(read_key, write_key);
        crypter.new_construction = true;

        let ct = crypter.encrypt(&r).unwrap();

        assert_eq!(ct.len(), expected_req_crypted.len());
        assert_eq!(&ct, &expected_req_crypted);

        let mut peer_crypter = Crypter::new(write_key, read_key);
        let pt = peer_crypter.decrypt(&ct).unwrap();
        assert_eq!(pt, r);
        let msg = CableFrame::from_bytes(1, &pt);
        assert_eq!(msg.message_type, MessageType::Ctap);
    }
}
